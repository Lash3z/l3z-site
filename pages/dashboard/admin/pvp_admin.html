<!DOCTYPE html>
<html lang="en" data-admin="checking">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PVP — Tournament Admin</title>
<link rel="icon" type="image/png" href="/assets/L3Z_logoMain.png">
<style>
:root{
  --bg:#060b0d; --panel:#0b1417; --ink:#eaf7ff; --muted:#9fd0d6;
  --line:rgba(0,255,255,.18); --teal:#00ffff; --gold:#ffb42d; --ok:#12d48a; --bad:#e25a6f;
}
*{box-sizing:border-box}
html,body{margin:0;background:var(--bg);color:var(--ink);font-family:Segoe UI,system-ui,Arial,sans-serif}
html[data-admin="checking"] body{opacity:0;transition:opacity .12s ease}
h1{margin:16px 0 8px;color:var(--teal);text-shadow:0 0 14px #00ffff55}
h2{margin:0 0 10px;font-size:16px;color:var(--ink)}
.wrap{max-width:1400px;margin:0 auto;padding:0 16px 48px}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.card{background:linear-gradient(180deg,#0a1418,#0a1216);border:1px solid var(--line);border-radius:14px;padding:12px;margin-top:12px}
.pill{padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:#081318;color:#cfffff}
.btn{border:1px solid var(--line);border-radius:10px;padding:8px 12px;background:#0f1720;color:var(--ink);font-weight:800;cursor:pointer}
.btn.ok{background:#103d30;border-color:#1fa37b}
.btn.warn{background:#231b0f;border-color:#8c6926}
.btn.bad{background:#2b1116;border-color:#7e2a3c}
.btn[disabled]{opacity:.6;cursor:not-allowed}
.input,textarea,select{background:#0c1519;border:1px solid var(--line);border-radius:10px;color:#eaf7ff;padding:8px}
.hint{color:var(--muted);font-size:12px}

/* Bracket */
.brWrap{display:grid;grid-template-columns:1fr auto 1fr;gap:14px;margin-top:12px}
.side{border:1px solid var(--line);border-radius:12px;background:#0b1418;padding:10px;overflow:auto}
.sideHead{display:flex;align-items:center;justify-content:space-between;margin:0 0 8px 0;color:#9fd0d6;font-size:13px}
.scroller{display:flex;flex-direction:row;align-items:flex-start}
.rcol{display:flex;flex-direction:column;gap:12px;min-width:220px;margin-right:12px}
.rlbl{font-size:12px;color:#9fd0d6;margin:2px 0 0 2px}
.match{background:#0c1519;border:1px solid var(--line);border-radius:10px;padding:8px 10px;min-height:64px}
.slot{display:flex;justify-content:space-between;gap:10px}
.name{font-weight:900}
.name.editable{cursor:text;border-bottom:1px dashed rgba(0,255,255,.25)}
.game{font-size:12px;color:#9fd0d6}
.vs{margin:4px 0 0 0;font-size:11px;opacity:.8}
.scoreSm{font-weight:900;padding:2px 6px;border:1px solid var(--line);border-radius:8px;background:#0d1820;min-width:34px;text-align:center}
.center{display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:flex-start;min-width:280px}
.finalCard{border:1px solid var(--line);border-radius:12px;background:#0b1418;padding:12px;width:100%}
.centerTitle{display:flex;align-items:center;justify-content:space-between;color:#9fd0d6;font-size:13px;margin:0 0 8px 0}
.champ{display:flex;gap:10px;align-items:center;justify-content:center;border:1px solid var(--line);border-radius:12px;background:#0c161a;padding:12px}
.champ .name{font-size:18px}
.chip{border:1px solid var(--line);border-radius:999px;padding:4px 10px;background:#081318;color:#cfffff;font-size:12px}

/* Current match */
.cur{display:grid;grid-template-columns:1fr auto 1fr;gap:10px;border:1px solid var(--line);border-radius:12px;background:#0b1418;padding:12px;margin-top:8px;align-items:center}
.cur .title{font-weight:900}
.cur .big{font-size:18px}
.sep{font-weight:900;color:#9fe;text-align:center}

/* small toasts */
.toast{position:fixed;right:16px;bottom:16px;background:#0b1f21;border:1px solid var(--line);border-radius:10px;padding:10px 12px;opacity:0;transform:translateY(8px);transition:.2s all;pointer-events:none}
.toast.on{opacity:1;transform:translateY(0)}
</style>
</head>
<body>
<div class="wrap">
  <div class="row" style="justify-content:space-between;align-items:center;margin-top:8px">
    <h1>PVP — Tournament Admin</h1>
    <div class="row">
      <a class="btn" href="/index.html">← Back to Dashboard</a>
      <button id="adminLogout" class="btn">Log out</button>
    </div>
  </div>

  <!-- Build / Seed -->
  <div class="card">
    <h2>Build / Seed Bracket</h2>
    <div class="row">
      <label>Size
        <select id="sizeSel" class="input">
          <option value="16">16</option>
          <option value="32">32</option>
        </select>
      </label>
      <label><input type="checkbox" id="useEntries"> Use PVP entries (approved → first)</label>
      <label><input type="checkbox" id="useLists"> Use Super/Mega Hunt for games & fillers</label>
      <label><input type="checkbox" id="autoGames" checked> Auto-assign games to first round</label>
      <button id="autoSeed" class="btn">Auto-seed</button>
      <button id="buildBtn" class="btn ok">Build / Reset</button>
      <span id="seedCount" class="pill">Seeds: 0</span>
    </div>
    <div class="row" style="margin-top:8px">
      <textarea id="manualSeeds" class="input" placeholder="Paste extra player names here (one per line)" rows="3" style="flex:1 1 520px"></textarea>
      <textarea id="manualGames" class="input" placeholder="Optional: paste game titles here (one per line) to assign to first round" rows="3" style="flex:1 1 520px"></textarea>
    </div>
    <div class="hint" style="margin-top:6px">
      Auto-seed pulls **approved** PVP entries from the server first, then fills remaining slots from your lists or manual seeds.
      Super/Mega Hunt lists are read from localStorage (e.g. <code>bg:superhunt:list</code>, <code>bg:megahunt:list</code>, or <code>bg:builder:battleground.games</code>).
    </div>
  </div>

  <!-- Current Match controller -->
  <div class="card">
    <h2>Current Match</h2>
    <div class="row">
      <span id="cursorBadge" class="pill">—</span>
      <button id="prevBtn" class="btn">Prev</button>
      <button id="nextBtn" class="btn">Next</button>
      <button id="resetBtn" class="btn warn">Reset Bracket (keep seeds)</button>
      <span id="saveStamp" class="pill">—</span>
    </div>
    <div id="cur" class="cur" aria-live="polite">
      <div class="left">
        <div class="title">Left</div>
        <div id="curL" class="big">—</div>
        <div class="row">
          <label>Score <input id="curLS" class="input" type="number" step="1" style="width:100px"></label>
        </div>
      </div>
      <div class="sep">VS</div>
      <div class="right">
        <div class="title">Right</div>
        <div id="curR" class="big">—</div>
        <div class="row">
          <label>Score <input id="curRS" class="input" type="number" step="1" style="width:100px"></label>
        </div>
      </div>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="lWin" class="btn ok">Left wins</button>
      <button id="rWin" class="btn ok">Right wins</button>
    </div>
  </div>

  <!-- Bracket viewer/editor -->
  <div class="card">
    <h2>Bracket</h2>
    <div id="brWrap" class="brWrap">
      <!-- injected -->
    </div>
  </div>
</div>

<div id="toast" class="toast">Saved.</div>

<script>
(function(){
  "use strict";
  const API="";
  const $=(s,r=document)=>r.querySelector(s);
  const $$=(s,r=document)=>Array.from((r||document).querySelectorAll(s));
  const toast=t=>{ const b=$("#toast"); b.textContent=t; b.classList.add("on"); setTimeout(()=>b.classList.remove("on"),1100); };

  // ---- Admin gate ----
  const H=document.documentElement;
  function lock(){
    H.removeAttribute("data-admin");
    const wrap=document.createElement("div");
    wrap.style.cssText="min-height:100vh;display:flex;align-items:center;justify-content:center";
    wrap.innerHTML='<div style="max-width:640px;margin:24px;padding:24px;border:1px solid rgba(0,255,255,.2);border-radius:14px;background:rgba(0,0,0,.75)"><h1>Administration Locked</h1><div>You must unlock admin on the <a href="/pages/dashboard/home/admin_login.html?redirect=%2Fpages%2Fdashboard%2Fadmin%2Fpvp_admin.html">Admin Login</a> first.</div><div style="margin-top:14px"><a href="/index.html">Back to Dashboard</a></div></div>';
    document.body.innerHTML=""; document.body.appendChild(wrap);
  }
  fetch(API+"/api/admin/gate/check",{credentials:"include",cache:"no-store"})
    .then(r=>r.ok?r.json():null).then(j=>{ if(j&&j.admin){ H.removeAttribute("data-admin"); boot(); } else lock(); })
    .catch(lock);

  // ---- State ----
  let builder=null;  // { lastUpdated, bracket:{ size, east[], west[], finals[], cursor, champion, meta } }
  let seedsEast=[], seedsWest=[], gamesList=[];

  // ---- Utilities ----
  function esc(s){ s = String(s==null?'':s); return s.replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]); }
  function up(s){ return (s||"").toString().trim().toUpperCase(); }
  function readList(key){ try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : null; }catch{ return null; } }
  function lines(t){ return String(t||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean); }

  // ---- Seeding helpers ----
  async function fetchApprovedEntries(){
    try{
      const r = await fetch(API+"/api/pvp/entries",{credentials:"include",cache:"no-store"});
      if(!r.ok) return [];
      const j = await r.json();
      const arr = (j.entries||[]).filter(e=> (e.status||"pending").toLowerCase()==="approved");
      // keep side preference if provided
      const east = arr.filter(e=> (e.side||"EAST").toUpperCase()==="EAST").map(e=>({name:up(e.username||e.name||""), img:""}));
      const west = arr.filter(e=> (e.side||"WEST").toUpperCase()==="WEST").map(e=>({name:up(e.username||e.name||""), img:""}));
      return { east, west };
    }catch{ return { east:[], west:[] }; }
  }
  function gatherHuntGames(){
    // Try a few likely keys
    const out=[];
    const bgBuilder = readList("bg:builder:battleground");
    if(bgBuilder && bgBuilder.games && Array.isArray(bgBuilder.games)){
      for(const g of bgBuilder.games){ const t=g.title||g.name; if(t) out.push({title:String(t)}); }
    }
    const sh = readList("bg:superhunt:list");
    if(Array.isArray(sh)) for(const t of sh){ if(t) out.push({title:String(t)}); }
    const mh = readList("bg:megahunt:list");
    if(Array.isArray(mh)) for(const t of mh){ if(t) out.push({title:String(t)}); }
    return out;
  }

  async function autoSeed(){
    seedsEast=[]; seedsWest=[]; gamesList=[];
    const size = +$("#sizeSel").value;
    const capacity = size/2; // per side

    if($("#useEntries").checked){
      const {east,west} = await fetchApprovedEntries();
      seedsEast = east.slice(0, capacity);
      seedsWest = west.slice(0, capacity);
    }

    const manual = lines($("#manualSeeds").value).map(n=>({name:up(n)}));
    // backfill remaining with manual names alternating sides
    const fillRemaining = ()=> {
      const needE = capacity - seedsEast.length;
      const needW = capacity - seedsWest.length;
      let idx=0;
      while((seedsEast.length<capacity || seedsWest.length<capacity) && idx<manual.length){
        if(seedsEast.length<capacity){ seedsEast.push(manual[idx]); idx++; }
        if(seedsWest.length<capacity && idx<manual.length){ seedsWest.push(manual[idx]); idx++; }
      }
    };
    fillRemaining();

    if($("#useLists").checked || $("#autoGames").checked){
      const fromLocal = gatherHuntGames();
      const manualGames = lines($("#manualGames").value).map(t=>({title:t}));
      gamesList = (manualGames.length? manualGames : fromLocal);
    }

    // if still not enough seeds, generate fillers from games
    const filler = i => ({ name: up((gamesList[i % Math.max(1,gamesList.length)]?.title)||`BOT_${i+1}`) });
    while(seedsEast.length < capacity){ seedsEast.push(filler(seedsEast.length)); }
    while(seedsWest.length < capacity){ seedsWest.push(filler(seedsWest.length)); }

    $("#seedCount").textContent = `Seeds: ${seedsEast.length + seedsWest.length}`;
    toast("Seed list prepared");
  }

  async function buildOrReset(){
    const size = +$("#sizeSel").value;
    const body = {
      size,
      eastSeeds: seedsEast,
      westSeeds: seedsWest,
      games: $("#autoGames").checked ? gamesList : []
    };
    const r = await fetch(API+"/api/pvp/bracket",{method:"POST",credentials:"include",headers:{"Content-Type":"application/json"},body:JSON.stringify(body)});
    if(!r.ok){ toast("Build failed"); return; }
    const j = await r.json();
    builder = j.builder; paintAll();
    toast("Bracket built");
  }

  // ---- Bracket fetch/save ----
  async function loadBracket(){
    const r = await fetch(API+"/api/pvp/bracket",{cache:"no-store"});
    if(!r.ok){ builder=null; return; }
    const j = await r.json();
    builder = j.builder || null;
  }

  function paintAll(){
    $("#saveStamp").textContent = builder && builder.lastUpdated ? ("Saved @ "+new Date(builder.lastUpdated).toLocaleTimeString()) : "—";
    paintCurrent();
    paintBracket();
  }

  function phaseLabel(p){ return p==="east"?"EAST":p==="west"?"WEST":"FINALS"; }

  function paintCurrent(){
    const cur = (builder && builder.bracket && builder.bracket.cursor) || null;
    const set = (t, l)=>{ t.textContent=l; };
    if(!builder || !builder.bracket || !cur){ $("#cursorBadge").textContent="—"; $("#curL").textContent="—"; $("#curR").textContent="—"; return; }
    $("#cursorBadge").textContent = `${phaseLabel(cur.phase)} • R${cur.roundIndex+1} • M${cur.matchIndex+1}`;
    const m = getMatch(cur.phase, cur.roundIndex, cur.matchIndex);
    set($("#curL"), m?.left?.name || "—");
    set($("#curR"), m?.right?.name || "—");
    $("#curLS").value = m?.left?.score ?? "";
    $("#curRS").value = m?.right?.score ?? "";
  }

  function getMatch(phase, ri, mi){
    const br = builder && builder.bracket; if(!br) return null;
    const arr = phase==="east"?br.east: phase==="west"?br.west: br.finals;
    return (arr && arr[ri|0] && arr[ri|0][mi|0]) ? arr[ri|0][mi|0] : null;
  }

  function setCursorToNextPending(){
    // rely on server’s cursor after progress; but allow manual Next/Prev
    loadBracket().then(paintAll).catch(()=>{});
  }

  async function progress(w){
    const cur = builder && builder.bracket && builder.bracket.cursor; if(!cur) return;
    const body = {
      phase: cur.phase, roundIndex: cur.roundIndex, matchIndex: cur.matchIndex,
      winner: w,
      leftScore: ($("#curLS").value===""? null : +$("#curLS").value),
      rightScore: ($("#curRS").value===""? null : +$("#curRS").value)
    };
    const r = await fetch(API+"/api/pvp/bracket/progress",{method:"POST",credentials:"include",headers:{"Content-Type":"application/json"},body:JSON.stringify(body)});
    if(!r.ok){ toast("Progress failed"); return; }
    const j = await r.json();
    builder = j.builder || builder;
    paintAll();
    toast("Advanced");
  }

  function roundLabelByCount(total, idx){
    if (total<=1) return "SF";
    if (total===2) return idx===0 ? "QF" : "SF";
    if (total>=3){
      if (idx===total-1) return "SF";
      if (idx===total-2) return "QF";
      const size = 1<<((total-idx)); // approx
      if (size>=64) return "R64";
      if (size>=32) return "R32";
      if (size>=16) return "R16";
      if (size>=8)  return "R8";
      return "R"+size;
    }
    return "Round "+(idx+1);
  }

  function matchEl(m, phase, ri, mi){
    const d=document.createElement("div"); d.className="match";
    const lName = esc(m?.left?.name||"");
    const rName = esc(m?.right?.name||"");
    const game  = esc(m?.game||"");
    d.innerHTML =
      `<div class="slot"><div class="name editable" data-side="left">${lName||"—"}</div><div>${m.left?.score!=null?`<span class="scoreSm">${m.left.score}</span>`:""}</div></div>`+
      `<div class="vs">vs ${game?`• <span class="game">${game}</span>`:""}</div>`+
      `<div class="slot"><div class="name editable" data-side="right">${rName||"—"}</div><div>${m.right?.score!=null?`<span class="scoreSm">${m.right.score}</span>`:""}</div></div>`;
    // Inline edit
    d.querySelectorAll(".name.editable").forEach(el=>{
      el.addEventListener("click", ()=>inlineEdit(el, phase, ri, mi));
    });
    return d;
  }

  function inlineEdit(el, phase, ri, mi){
    const side = el.getAttribute("data-side");
    const old = el.textContent.trim()==="—"?"":el.textContent.trim();
    const inp = document.createElement("input");
    inp.className="input"; inp.value=old; inp.style.width="100%";
    el.replaceWith(inp); inp.focus(); inp.selectionStart=inp.value.length;
    const commit = async ()=>{
      const name = inp.value.trim();
      // patch server
      const r = await fetch(API+"/api/pvp/bracket/slot",{method:"PATCH",credentials:"include",headers:{"Content-Type":"application/json"},body:JSON.stringify({phase, roundIndex:ri, matchIndex:mi, side, name})});
      if(!r.ok){ toast("Edit failed"); return paintAll(); }
      await loadBracket(); paintAll();
    };
    inp.addEventListener("blur", commit);
    inp.addEventListener("keydown", e=>{ if(e.key==="Enter") commit(); if(e.key==="Escape") paintAll(); });
  }

  function sideCol(title, list, phase){
    const col=document.createElement("div"); col.className="side";
    const head=document.createElement("div"); head.className="sideHead";
    head.innerHTML = `<div>${esc(title)}</div><div class="chip">${list.length} Rounds</div>`;
    col.appendChild(head);

    const sc=document.createElement("div"); sc.className="scroller";
    const total=list.length;
    list.forEach((round, idx)=>{
      const rc=document.createElement("div"); rc.className="rcol";
      const lbl=document.createElement("div"); lbl.className="rlbl"; lbl.textContent = roundLabelByCount(total, idx);
      rc.appendChild(lbl);
      round.forEach((m,mi)=> rc.appendChild(matchEl(m, phase, idx, mi)));
      sc.appendChild(rc);
    });
    col.appendChild(sc);
    return col;
  }

  function paintBracket(){
    const wrap=$("#brWrap"); wrap.innerHTML="";
    const b = builder && builder.bracket; if(!b){ wrap.innerHTML='<div class="hint">No bracket yet. Build it above.</div>'; return; }
    wrap.appendChild(sideCol("EAST", b.east, "east"));

    const center=document.createElement("div"); center.className="center";
    // finals
    if (Array.isArray(b.finals)){
      b.finals.forEach((round,idx)=>{
        const f=document.createElement("div"); f.className="finalCard";
        const lbl = (idx===b.finals.length-1 && round.length===1) ? "GRAND FINAL" : ("FINALS R"+(idx+1));
        f.innerHTML = `<div class="centerTitle"><div>${esc(lbl)}</div><div class="chip">${esc((b.meta&&b.meta.bestOf)?("Bo"+b.meta.bestOf):"")}</div></div>`;
        round.forEach((m,mi)=> f.appendChild(matchEl(m,"finals",idx,mi)));
        center.appendChild(f);
      });
    }
    // champion
    if (b.champion && b.champion.name){
      const c = document.createElement("div"); c.className="finalCard";
      c.innerHTML = '<div class="centerTitle"><div>Champion</div><div class="chip">E vs W</div></div>';
      const box = document.createElement("div"); box.className="champ";
      box.innerHTML = `<div class="name">${esc(b.champion.name)}</div>`;
      c.appendChild(box);
      center.appendChild(c);
    }
    wrap.appendChild(center);

    wrap.appendChild(sideCol("WEST", b.west, "west"));
  }

  // Navigate cursor to next/prev pending (client-side walk; server will also adjust after progress)
  function findAllPending(){
    const b = builder && builder.bracket; if(!b) return [];
    const out=[];
    const pushPhase=(ph, arr)=>{
      for(let r=0;r<arr.length;r++) for(let m=0;m<arr[r].length;m++){
        if((arr[r][m].status||"pending")!=="done") out.push({phase:ph,roundIndex:r,matchIndex:m});
      }
    };
    pushPhase("east", b.east); pushPhase("west", b.west); pushPhase("finals", b.finals||[]);
    return out;
  }

  async function moveCursor(offset){
    const b = builder && builder.bracket; if(!b) return;
    const cur = b.cursor || {phase:"east", roundIndex:0, matchIndex:0};
    const pend = findAllPending();
    if(!pend.length){ toast("No pending matches"); return; }
    // find current in the pending list; if not found, go first/last by offset
    let idx = pend.findIndex(p=>p.phase===cur.phase && p.roundIndex===cur.roundIndex && p.matchIndex===cur.matchIndex);
    if(idx===-1) idx = (offset>0? -1 : 0);
    const next = pend[(idx + pend.length + offset)%pend.length];
    // Patch the cursor by a harmless slot edit (tiny trick) or just reload (cursor is server-driven on progress; for nav we mimic client)
    b.cursor = next; paintAll();
  }

  // ---- Wire buttons ----
  $("#autoSeed").addEventListener("click", autoSeed);
  $("#buildBtn").addEventListener("click", buildOrReset);
  $("#lWin").addEventListener("click", ()=>progress("L"));
  $("#rWin").addEventListener("click", ()=>progress("R"));
  $("#prevBtn").addEventListener("click", ()=>moveCursor(-1));
  $("#nextBtn").addEventListener("click", ()=>moveCursor(+1));
  $("#resetBtn").addEventListener("click", async ()=>{
    if(!confirm("Reset all progress but keep the seeded players?")) return;
    const r = await fetch(API+"/api/pvp/bracket/reset",{method:"POST",credentials:"include"});
    if(!r.ok){ toast("Reset failed"); return; }
    await loadBracket(); paintAll(); toast("Bracket reset");
  });

  $("#adminLogout").addEventListener("click", async ()=>{
    try{ await fetch("/api/admin/gate/logout",{method:"POST",credentials:"include"}); }catch{}
    location.href="/index.html";
  });

  // start
  loadBracket().then(paintAll);
})();
</script>
</body>
</html>
