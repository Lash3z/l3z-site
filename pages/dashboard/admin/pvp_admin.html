<!DOCTYPE html>
<html lang="en" data-admin="checking">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="robots" content="noindex,nofollow"/>
  <title>PVP — Admin Tournament Builder</title>
  <link rel="icon" type="image/png" href="/assets/L3Z_logoMain.png">
  <style>
    :root{
      --bg:#060b0d; --panel:#0b1417; --ink:#eaf7ff; --muted:#9fd0d6;
      --line:rgba(0,255,255,.18); --teal:#00ffff; --gold:#ffb42d;
      --ok:#12d48a; --bad:#e25a6f; --warn:#ffca75;
      --east:#2bb0ff; --west:#ffa94d;
    }
    *{box-sizing:border-box}
    html,body{margin:0;background:var(--bg);color:var(--ink);font-family:Segoe UI,system-ui,Arial,sans-serif}
    /* prevent flash until admin check completes */
    html[data-admin="checking"] body{opacity:0;transition:opacity .12s ease}

    a.btn,button.btn{border:1px solid var(--line);border-radius:10px;padding:8px 12px;background:#0f1720;color:var(--ink);font-weight:800;cursor:pointer;text-decoration:none;display:inline-flex;align-items:center;gap:8px}
    .btn.ok{background:#103d30;border-color:#1fa37b}
    .btn.warn{background:#231b0f;border-color:#8c6926}
    .btn.bad{background:#2b1116;border-color:#7e2a3c}
    .btn[disabled]{opacity:.6;cursor:not-allowed}

    .wrap{max-width:1300px;margin:0 auto;padding:0 14px 40px}
    h1{margin:16px 0 8px;color:var(--teal);text-shadow:0 0 14px #00ffff55}
    h2{margin:0 0 10px;font-size:16px;color:var(--ink)}

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .panel{background:linear-gradient(180deg,#0a1418,#0a1216);border:1px solid var(--line);border-radius:14px;padding:12px;margin-top:12px}
    .pill{padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:#081318;color:#cfffff}
    .hint{color:var(--muted);font-size:12px}
    .badge{padding:4px 8px;border-radius:999px;border:1px solid var(--line);background:#081318;color:#bfe}
    .right{margin-left:auto}

    .tbl{width:100%;border-collapse:separate;border-spacing:0}
    .tbl th,.tbl td{border-bottom:1px solid rgba(255,255,255,.06);padding:8px;text-align:left;font-size:13px}
    .tbl th{color:var(--muted)}

    /* bracket */
    .bracket{
      display:grid;gap:14px;margin-top:10px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }
    .round{border:1px solid var(--line);border-radius:12px;background:#0b1418;padding:12px}
    .round h3{margin:0 0 8px 0;font-size:14px;color:#cfe}
    .match{border:1px solid var(--line);border-radius:10px;background:#0e1519;margin:10px 0;padding:8px}
    .slot{display:flex;align-items:center;gap:8px;padding:6px;border-radius:8px}
    .slot.east{background:rgba(43,176,255,.08);border:1px solid rgba(43,176,255,.18)}
    .slot.west{background:rgba(255,169,77,.08);border:1px solid rgba(255,169,77,.18)}
    .slot .team{font-weight:800}
    .slot .game{font-size:12px;color:#cfe;opacity:.9}
    .slot .edit{margin-left:auto;font-size:12px;opacity:.8;cursor:pointer}
    .slot .edit:hover{opacity:1}
    .vs{display:flex;justify-content:center;color:#9fe;font-weight:900;margin:6px 0}
    .act{display:flex;gap:8px;justify-content:space-between;margin-top:6px}
    .act .btn{flex:1 1 auto;justify-content:center}

    .centerCard{border:1px dashed var(--line);background:#0a1215;border-radius:12px;padding:12px}
    .log{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:12px;max-height:160px;overflow:auto;border:1px solid var(--line);border-radius:8px;padding:8px;background:#0b1216}

    /* lock screen */
    .lockwrap{min-height:100vh;display:flex;align-items:center;justify-content:center;background:#0b0f12;color:#eaf7ff}
    .lockcard{max-width:640px;margin:24px;padding:24px;border:1px solid rgba(0,255,255,.2);border-radius:14px;background:rgba(0,0,0,.75);box-shadow:0 0 18px rgba(0,255,255,.15)}
    .lockcard h1{margin:0 0 10px;color:#cfe}
    .lockcard a{color:#7ad7ff}
  </style>
</head>
<body>
<div class="wrap">
  <div class="row" style="justify-content:space-between;align-items:center;margin-top:8px">
    <h1>PVP — Admin Tournament Builder</h1>
    <div class="row">
      <a class="btn" href="/index.html">← Back to Dashboard</a>
      <button id="adminLogout" class="btn">Log out</button>
    </div>
  </div>

  <!-- Controls -->
  <div class="panel">
    <div class="row">
      <h2 style="margin-right:10px">Auto-Seed & Build</h2>
      <span id="entryCount" class="badge">Entries: —</span>
      <span class="right"></span>
      <label class="pill">Bracket Size
        <select id="bracketSize" style="margin-left:8px;background:#0c1518;color:#eaf7ff;border:1px solid var(--line);border-radius:8px;padding:6px">
          <option value="16" selected>16</option>
          <option value="32">32</option>
        </select>
      </label>
      <label class="pill"><input id="approvedOnly" type="checkbox" checked style="vertical-align:middle;margin-right:6px">Approved first (use pending if needed)</label>
      <label class="pill"><input id="noDupGames" type="checkbox" checked style="vertical-align:middle;margin-right:6px">No duplicate games (global)</label>
      <button id="refreshEntries" class="btn">Refresh Entries</button>
      <button id="autoSeed" class="btn ok">Auto-seed & Build</button>
      <button id="shuffleSeed" class="btn">Shuffle Seeds</button>
      <button id="clearBracket" class="btn bad">Clear Bracket</button>
      <button id="saveLive" class="btn warn">Save → Live</button>
    </div>
    <div class="hint" style="margin-top:6px">
      Auto-seed rule: use <b>player entries first</b> (EAST/WEST), dedupe players & games; then fill remaining slots from Super/Mega Hunt pools (no duplicates either).
      If two players requested the same game, the second will be <b>auto-swapped</b> to a free game from the pool (logged below).
    </div>
  </div>

  <!-- Entries -->
  <div class="panel">
    <div class="row" style="align-items:center">
      <h2 style="margin-right:10px">Player Entries</h2>
      <span id="entBadge" class="badge">—</span>
      <span class="right"></span>
      <button id="entReload" class="btn ok">Reload</button>
    </div>
    <div style="max-height:280px;overflow:auto;border:1px solid var(--line);border-radius:10px;margin-top:8px">
      <table class="tbl" id="entTbl" aria-label="PVP entries">
        <thead>
          <tr>
            <th>When</th>
            <th>Username</th>
            <th>Side</th>
            <th>Game (Requested)</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody><tr><td colspan="5" class="hint">Loading…</td></tr></tbody>
      </table>
    </div>
  </div>

  <!-- Bracket -->
  <div class="panel">
    <div class="row" style="align-items:center">
      <h2 style="margin-right:10px">Tournament Bracket</h2>
      <span id="brInfo" class="pill">—</span>
      <span class="right"></span>
      <span class="hint">Click a name or game to edit. Use “Left Wins” / “Right Wins” to advance winners.</span>
    </div>

    <div id="bracket" class="bracket"></div>

    <div class="centerCard" style="margin-top:10px">
      <div class="row"><strong>Build Log</strong><span class="right"></span><span id="logTime" class="hint">—</span></div>
      <pre id="log" class="log">Ready.</pre>
    </div>
  </div>
</div>

<script>
(function(){
  "use strict";
  const API = ""; // allow prefixing if this page sits behind a sub-path
  const H=document.documentElement;
  H.setAttribute("data-admin","checking");

  // ----- utilities
  const $=(s,r=document)=>r.querySelector(s);
  const $all=(s,r=document)=>Array.from(r.querySelectorAll(s));
  const up=s=>(s||"").toString().trim().toUpperCase();
  const esc=s=>String(s==null?"":s).replace(/[&<>"']/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}[c]));
  const log=(...a)=>{ const t=$("#log"); const ts=new Date().toLocaleTimeString(); t.textContent += "\\n["+ts+"] "+a.join(" "); t.scrollTop=t.scrollHeight; $("#logTime").textContent="Updated "+ts; };

  // ----- state
  let ENTRIES=[]; // from server
  let BRACKET=null; // in-memory bracket
  let SEED_E=[], SEED_W=[]; // current round seeding (left=E, right=W)
  let USED_GAMES=new Set(); // case-insensitive uniqueness
  const LS_BUILDER_KEY="pv:builder:pvp";

  // ----- AdminGate
  function lock(){
    H.removeAttribute("data-admin");
    const wrap=document.createElement("div");
    wrap.className="lockwrap";
    const redir = encodeURIComponent(location.pathname+location.search);
    wrap.innerHTML = '<div class="lockcard"><h1>Administration Locked</h1><div>You must unlock admin on the <a href="/pages/dashboard/admin/admin_login.html?redirect='+redir+'">Admin Login</a> first.</div><div style="margin-top:8px;font-size:12px;opacity:.85">If you already logged in, your session may have expired.</div><div style="margin-top:14px"><a href="/index.html">Back to Dashboard</a></div></div>';
    document.body.innerHTML="";
    document.body.appendChild(wrap);
  }
  fetch(API+"/api/admin/gate/check",{credentials:"include",cache:"no-store"})
    .then(r=>r.ok?r.json():null)
    .then(j=>{ if(j&&j.admin){ H.removeAttribute("data-admin"); boot(); } else lock(); })
    .catch(lock);

  // ----- boot
  function boot(){
    wireUI();
    loadEntries();
    loadSavedBracket();
  }

  // == UI wiring
  function wireUI(){
    $("#adminLogout").addEventListener("click", async ()=>{
      try{ await fetch(API+"/api/admin/gate/logout",{method:"POST",credentials:"include"});}catch{}
      location.href="/index.html";
    });
    $("#refreshEntries").addEventListener("click", loadEntries);
    $("#entReload").addEventListener("click", loadEntries);
    $("#autoSeed").addEventListener("click", autoSeedAndBuild);
    $("#shuffleSeed").addEventListener("click", ()=>{ shuffle(SEED_E); shuffle(SEED_W); buildBracketFromSeeds(); saveLiveSilent(); });
    $("#clearBracket").addEventListener("click", ()=>{ BRACKET=null; SEED_E=[]; SEED_W=[]; USED_GAMES.clear(); paintBracket(); saveLiveSilent(); log("Cleared bracket."); });
    $("#saveLive").addEventListener("click", saveLiveExplicit);
  }

  // == entries
  async function loadEntries(){
    const tbody=$("#entTbl tbody");
    tbody.innerHTML='<tr><td colspan="5" class="hint">Loading…</td></tr>';
    try{
      const r = await fetch(API+"/api/pvp/entries",{credentials:"include",cache:"no-store"});
      if(!r.ok) throw 0;
      const j = await r.json();
      ENTRIES = Array.isArray(j.entries)? j.entries : [];
      $("#entryCount").textContent = "Entries: "+ENTRIES.length;
      $("#entBadge").textContent = ENTRIES.length;

      if(!ENTRIES.length){
        tbody.innerHTML='<tr><td colspan="5" class="hint">No entries yet.</td></tr>';
        return;
      }
      tbody.innerHTML = ENTRIES.map(e=>{
        const when = e.ts ? new Date(e.ts).toLocaleString() : "—";
        const user = up(e.username||"");
        const side = up(e.side||"EAST");
        const game = e.game||"—";
        const status = (e.status||"pending").toLowerCase();
        return `<tr>
          <td>${esc(when)}</td><td><b>${esc(user)}</b></td><td>${esc(side)}</td>
          <td>${esc(game)}</td><td><span class="badge">${esc(status)}</span></td>
        </tr>`;
      }).join("");
      log("Loaded", ENTRIES.length, "entries.");
    }catch{
      tbody.innerHTML='<tr><td colspan="5" class="hint">Failed to load entries.</td></tr>';
      $("#entryCount").textContent = "Entries: —";
      $("#entBadge").textContent = "—";
      log("Failed to load entries.");
    }
  }

  // == game pools (Super/Mega Hunt) from localStorage or fallback
  function loadGamePool(){
    const tryKeys=[
      "sh:games:super","sh:games:mega",
      "bg:games:super","bg:games:mega",
      "superHunt","megaHunt","superHuntList","megaHuntList"
    ];
    let pool=[];
    for(const k of tryKeys){
      const val = lsGet(k);
      if(Array.isArray(val)) pool=pool.concat(val);
    }
    pool = pool.map(normGame).filter(g=>g && g.title);
    const seen=new Set(); const out=[];
    for(const g of pool){
      const key = up(g.title);
      if(!seen.has(key)){ seen.add(key); out.push(g); }
    }
    return out;
  }
  function normGame(x){
    if(!x) return null;
    const t = x.title || x.name || x.game || x.id || "";
    const img = x.imageUrl || x.image || x.img || "";
    const prov = x.provider || x.vendor || "";
    return { title: String(t), imageUrl: String(img), provider: String(prov) };
  }
  function lsGet(k){ try{ const v=localStorage.getItem(k); return v?JSON.parse(v):null; }catch{return null;} }

  // == seeding
  function sanitizeEntries(raw, opts){
    const approvedFirst = !!opts.approvedFirst;
    const includePending = !!opts.includePending;

    let east=[], west=[];
    const latestByUser = new Map();
    for(const e of raw){
      const u = up(e.username||"");
      if(!u) continue;
      const prev=latestByUser.get(u);
      if(!prev || new Date(e.ts||0) > new Date(prev.ts||0)) latestByUser.set(u, e);
    }
    const uniq = Array.from(latestByUser.values());

    const rank = s => (s==="approved"?0:(s==="pending"?1:2));
    uniq.sort((a,b)=> rank((a.status||"pending").toLowerCase()) - rank((b.status||"pending").toLowerCase()) );

    for(const e of uniq){
      const status = (e.status||"pending").toLowerCase();
      if(status!=="approved" && !includePending && approvedFirst) continue;
      const side = (e.side||"EAST").toUpperCase()==="WEST"?"WEST":"EAST";
      const game = (e.game||"").trim();
      const obj = {
        name: up(e.username||""),
        side,
        game,
        imageUrl: "",
        provider: "",
        from:"player"
      };
      if(side==="EAST") east.push(obj);
      else west.push(obj);
    }
    return { east, west };
  }

  function uniqueFill(east, west, size, noDupGames){
    USED_GAMES.clear();

    if(noDupGames){
      const pool = loadGamePool();
      const nextFree = makeFreeGamePicker(pool);
      const seenGame = new Set();
      function ensureUniqueGame(seed){
        const gKey = up(seed.game||"");
        if(!gKey){
          const pick = nextFree();
          if(pick) Object.assign(seed, { game: pick.title, imageUrl: pick.imageUrl, provider: pick.provider, from: seed.from||"seed" });
          return;
        }
        if(seenGame.has(gKey)){
          const pick = nextFree(gKey);
          if(pick) { log("Auto-swap game for", seed.name, "→", pick.title); Object.assign(seed, { game: pick.title, imageUrl: pick.imageUrl, provider: pick.provider, autoSwap:true }); }
        }else{
          seenGame.add(gKey);
          USED_GAMES.add(up(seed.game));
        }
      }
      east.forEach(ensureUniqueGame);
      west.forEach(ensureUniqueGame);
    }else{
      [...east, ...west].forEach(s=>{ if(s.game) USED_GAMES.add(up(s.game)); });
    }

    shuffle(east); shuffle(west);
    const needPerSide = size/2;
    east = east.slice(0, needPerSide);
    west = west.slice(0, needPerSide);

    const pool = loadGamePool();
    const nextFree = makeFreeGamePicker(pool);
    function fillSide(sideArr, sideName){
      while(sideArr.length < needPerSide){
        const pick = nextFree();
        if(!pick){
          const title = "SEED-"+sideName[0]+(sideArr.length+1);
          if(!USED_GAMES.has(up(title))) {
            sideArr.push({ name: title, side: sideName, game:title, imageUrl:"", provider:"", from:"seed" });
            USED_GAMES.add(up(title));
          }else{ break; }
          continue;
        }
        const seedName = "SEED-"+sideName[0]+String(sideArr.length+1).padStart(2,"0");
        sideArr.push({ name: seedName, side: sideName, game: pick.title, imageUrl: pick.imageUrl, provider: pick.provider, from:"seed" });
        USED_GAMES.add(up(pick.title));
      }
    }
    fillSide(east,"EAST");
    fillSide(west,"WEST");

    east = dedupeGamesStable(east);
    west = dedupeGamesStable(west);
    return { east, west };
  }

  function makeFreeGamePicker(pool){
    const bag = pool.slice();
    shuffle(bag);
    let i=0;
    return function(notThisUpper){
      while(i<bag.length){
        const g = bag[i++], key = up(g.title);
        if(key && !USED_GAMES.has(key) && key !== notThisUpper){
          USED_GAMES.add(key);
          return g;
        }
      }
      return null;
    };
  }
  function dedupeGamesStable(list){
    const seen=new Set(); const out=[];
    for(const s of list){
      const key=up(s.game||"");
      if(!key || !seen.has(key)){ out.push(s); if(key) seen.add(key); }
    }
    return out;
  }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } }

  // == build bracket
  async function autoSeedAndBuild(){
    const size = Number($("#bracketSize").value||16);
    const approvedFirst = $("#approvedOnly").checked;
    const noDupGames = $("#noDupGames").checked;

    if(size!==16 && size!==32){ alert("Only 16 or 32 supported."); return; }

    const { east, west } = sanitizeEntries(ENTRIES, { approvedFirst, includePending:true });
    const seeded = uniqueFill(east, west, size, noDupGames);
    SEED_E = seeded.east;
    SEED_W = seeded.west;

    buildBracketFromSeeds();
    await saveLiveSilent();
    log("Auto-seeded bracket:", size, "slots; E=", SEED_E.length, "W=", SEED_W.length);
  }

  function buildBracketFromSeeds(){
    const size = Math.min(SEED_E.length, SEED_W.length) * 2;
    if(size!==16 && size!==32){
      $("#brInfo").textContent="—";
      $("#bracket").innerHTML = '<div class="pill">Need at least 8 vs 8 (or 16 vs 16) seeds.</div>';
      return;
    }

    const round0 = [];
    for(let i=0;i<size/2;i++){
      round0.push({ id: "R0M"+(i+1), left: cloneSeed(SEED_E[i]), right: cloneSeed(SEED_W[i]), winner: null });
    }

    const rounds=[round0];
    let m = round0.length;
    while(m>1){
      const r=[];
      for(let i=0;i<m/2;i++){
        r.push({ id: "R"+rounds.length+"M"+(i+1), left:null, right:null, winner:null });
      }
      rounds.push(r);
      m=r.length;
    }

    BRACKET = { size, lastUpdated: Date.now(), rounds };
    paintBracket();
    $("#brInfo").textContent = "Size "+size+" • Rounds "+rounds.length;
  }

  function cloneSeed(s){ return s? { name:s.name, side:s.side, game:s.game, imageUrl:s.imageUrl||"", provider:s.provider||"", from:s.from||"" } : null; }

  function paintBracket(){
    const host=$("#bracket");
    host.innerHTML="";
    if(!BRACKET){ host.innerHTML='<div class="pill">No bracket yet.</div>'; return; }

    BRACKET.rounds.forEach((arr,idx)=>{
      const col=document.createElement("div");
      col.className="round";
      const labels16 = ["Round of 16","Quarter Finals","Semi Finals","Grand Final"];
      const labels32 = ["Round of 32","Round of 16","Quarter Finals","Semi Finals","Grand Final"];
      const labels = BRACKET.size===16?labels16:labels32;
      const label = labels[idx] || ("Round "+(idx+1));
      col.innerHTML='<h3>'+esc(label)+'</h3>';
      if(!arr.length){ col.innerHTML+='<div class="pill">—</div>'; host.appendChild(col); return; }

      arr.forEach((m,i)=>{
        const box=document.createElement("div");
        box.className="match";
        box.innerHTML = slotHTML(m.left, "east") + '<div class="vs">VS</div>' + slotHTML(m.right,"west") + actionsHTML();
        wireMatch(box, idx, i);
        col.appendChild(box);
      });

      host.appendChild(col);
    });
  }

  function slotHTML(seed, side){
    if(!seed) return '<div class="slot '+side+'"><div class="team">—</div><div class="game">—</div><div class="edit" title="Edit">✎</div></div>';
    const nm = esc(seed.name||"—");
    const gm = esc(seed.game||"—");
    const sd = (seed.side||side).toUpperCase()==="WEST"?"west":"east";
    const mark = seed.autoSwap? ' <span class="badge" title="Game auto-swapped to remove duplicates">auto</span>' : '';
    return `<div class="slot ${sd}">
      <div class="team" data-edit="name">${nm}</div>
      <div class="game" data-edit="game">${gm}${mark}</div>
      <div class="edit" title="Edit">✎</div>
    </div>`;
  }
  function actionsHTML(){
    return `<div class="act">
      <button class="btn ok" data-win="left">Left Wins</button>
      <button class="btn ok" data-win="right">Right Wins</button>
      <button class="btn" data-clear="winner">Clear</button>
    </div>`;
  }

  function wireMatch(box, rIdx, mIdx){
    // edit: reliably determine side by index (no DOM sibling tricks)
    const slots = box.querySelectorAll(".slot");
    slots.forEach((slot, idx)=>{
      const side = idx===0 ? "left" : "right";
      slot.querySelector(".edit")?.addEventListener("click", ()=>{
        const seed = getSeed(rIdx, mIdx, side);
        if(!seed) return;
        const newName = prompt("Edit name", seed.name||"");
        if(newName==null) return;
        const newGame = prompt("Edit game", seed.game||"");
        if(newGame==null) return;
        seed.name = up(newName);
        seed.game = up(newGame);
        seed.autoSwap = false;
        BRACKET.lastUpdated = Date.now();
        paintBracket(); saveLiveSilent();
      });
    });

    box.querySelectorAll("[data-win]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const side = btn.getAttribute("data-win")==="left" ? "left" : "right";
        setWinner(rIdx, mIdx, side);
      });
    });
    box.querySelectorAll("[data-clear='winner']").forEach(btn=>{
      btn.addEventListener("click", ()=>{ clearWinner(rIdx, mIdx); });
    });
  }

  function getSeed(rIdx, mIdx, side){
    const m = BRACKET && BRACKET.rounds && BRACKET.rounds[rIdx] && BRACKET.rounds[rIdx][mIdx];
    if(!m) return null;
    return side==="left" ? m.left : m.right;
  }

  function setWinner(rIdx, mIdx, side){
    const m = BRACKET.rounds[rIdx][mIdx];
    const winner = side==="left" ? m.left : m.right;
    if(!winner){ alert("Empty slot."); return; }
    m.winner = winner;

    if(rIdx < BRACKET.rounds.length-1){
      const nextIdx = Math.floor(mIdx/2);
      const nextSide = (mIdx % 2 === 0) ? "left" : "right";
      BRACKET.rounds[rIdx+1][nextIdx][nextSide] = cloneSeed(winner);
      BRACKET.rounds[rIdx+1][nextIdx].winner = null;
    }
    BRACKET.lastUpdated = Date.now();
    paintBracket(); saveLiveSilent();
  }

  function clearWinner(rIdx, mIdx){
    const m = BRACKET.rounds[rIdx][mIdx];
    m.winner = null;
    if(rIdx < BRACKET.rounds.length-1){
      const nextIdx = Math.floor(mIdx/2);
      const nextSide = (mIdx % 2 === 0) ? "left" : "right";
      BRACKET.rounds[rIdx+1][nextIdx][nextSide] = null;
      BRACKET.rounds[rIdx+1][nextIdx].winner = null;
    }
    BRACKET.lastUpdated = Date.now();
    paintBracket(); saveLiveSilent();
  }

  // == save/load
  function saveLiveToLocal(){
    const builder = toBuilderForLive(BRACKET);
    localStorage.setItem(LS_BUILDER_KEY, JSON.stringify(builder));
  }
  function toBuilderForLive(B){
    if(!B) return { games:[], matches:[], lastUpdated: Date.now() };
    const r0 = B.rounds[0] || [];
    const matches = r0.map(m=>({
      leftTitle: m.left?.name || "—",
      rightTitle: m.right?.name || "—",
      leftImg: m.left?.imageUrl || "",
      rightImg: m.right?.imageUrl || "",
      leftScore: 0, rightScore: 0,
      leftId: m.left?.game || "", rightId: m.right?.game || "",
      leftProvider: m.left?.provider || "", rightProvider: m.right?.provider || ""
    }));
    return { matches, bracket: B, lastUpdated: B.lastUpdated||Date.now() };
  }

  async function saveLiveSilent(){
    saveLiveToLocal();
    try{
      await fetch(API+"/api/pvp/bracket",{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        credentials:"include",
        body: JSON.stringify({ builder: toBuilderForLive(BRACKET) })
      });
      log("Saved to live (server).");
    }catch{
      log("Saved to local only (server endpoint not present).");
    }
  }
  async function saveLiveExplicit(){
    await saveLiveSilent();
    alert("Saved.");
  }
  function loadSavedBracket(){
    const raw = lsGet(LS_BUILDER_KEY);
    if(raw && raw.bracket){
      BRACKET = raw.bracket;
      paintBracket();
      $("#brInfo").textContent = "Size "+BRACKET.size+" • Rounds "+BRACKET.rounds.length+" (loaded)";
    }
  }

})();
</script>
</body>
</html>
